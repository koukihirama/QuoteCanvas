<%# locals: customization:, passage:, url:, submit_label:, fallback: { bg:, text:, font: } %>
<%= form_with model: customization,
              url: url,
              local: true,
              html: { autocomplete: "off" },
              class: "space-y-6" do |f| %>

  <%= f.hidden_field :id if customization.persisted? %>

  <% if customization.errors.any? %>
    <div class="alert alert-error">
      <span>入力にエラーがあるよ（<%= customization.errors.count %>件）</span>
      <ul class="list-disc pl-5">
        <% customization.errors.full_messages.each do |m| %>
          <li><%= m %></li>
        <% end %>
      </ul>
    </div>
  <% end %>

  <div class="grid gap-6 md:grid-cols-2 items-start">
    <!-- 左：フォーム -->
    <div class="space-y-5">
      <!-- フォント -->
      <div>
        <%= f.label :font, "フォント", class: "block font-semibold mb-1" %>
        <div class="flex gap-2 mb-2">
          <% [["Serif","var(--font-serif)"],["Sans","var(--font-sans)"],["Mono","var(--font-mono)"]].each do |label, val| %>
            <button type="button" class="btn btn-xs" data-quick-font="<%= val %>"><%= label %></button>
          <% end %>
        </div>
        <%= f.select :font,
              options_for_select([
                ["標準（Serif）", "var(--font-serif)"],
                ["標準（Sans）",  "var(--font-sans)"],
                ["等幅（Mono）",  "var(--font-mono)"]
              ], customization.font),
              { include_blank: "（未選択 = 既定）" },
              class: "select select-bordered w-full",
              data: { preview_target: "font" },
              aria: { describedby: "font-help" } %>
        <p id="font-help" class="text-xs opacity-70 mt-1">未選択ならシステム既定が使われるよ。</p>
        <% if customization.errors[:font].present? %>
          <p class="text-error text-xs mt-1"><%= customization.errors[:font].first %></p>
        <% end %>
      </div>

      <!-- 文字色 -->
      <%= render "color_field_with_palette",
            f: f,
            field: :color,
            label: "文字色 (#RRGGBB / #RGB)",
            placeholder: "#111827",
            picker_key: "textColor",
            default_color: customization.color.presence || fallback[:text] %>

      <!-- 背景色 -->
      <%= render "color_field_with_palette",
            f: f,
            field: :bg_color,
            label: "背景色 (#RRGGBB / #RGB)",
            placeholder: "#F9FAFB",
            picker_key: "bgColor",
            default_color: customization.bg_color.presence || fallback[:bg] %>

      <div class="flex gap-2">
        <%= f.submit submit_label, class: "btn btn-primary" %>
        <%= link_to "キャンセル", passage_path(passage), class: "btn btn-ghost" %>
      </div>
    </div>

    <!-- 右：sticky プレビュー -->
    <div class="md:sticky md:top-20">
      <div id="c-preview"
           class="relative rounded-2xl p-6 border card-lift"
           style="background:<%= fallback[:bg] %>; color:<%= fallback[:text] %>; font-family:<%= fallback[:font] %>;"
           data-fallback-bg="<%= fallback[:bg] %>"
           data-fallback-text="<%= fallback[:text] %>"
           data-fallback-font="<%= fallback[:font] %>">
        <div class="absolute inset-0 gh-grain pointer-events-none rounded-2xl"></div>

        <% if passage.title.present? || passage.author.present? %>
          <div class="text-[11px] opacity-70 mb-1 font-sans">
            <%= [passage.author, passage.title.presence&.yield_self { |t| "『#{t}』" }].compact.join(" ") %>
          </div>
        <% end %>

        <div class="text-lg md:text-2xl font-semibold leading-relaxed">
          <%= simple_format(h(passage.content)) %>
        </div>
      </div>
    </div>
  </div>
<% end %>

<script>
(function () {
  // より堅牢に（祖先 .rounded-3xl -> form -> document の順で探す）
  const root =
    document.currentScript.closest(".rounded-3xl") ||
    document.currentScript.closest("form") ||
    document;

  // 参照
  const card    = root.querySelector("#c-preview");
  const fontSel = root.querySelector('[data-preview-target="font"]');
  const textInp = root.querySelector('[data-preview-target="textColor"]');
  const bgInp   = root.querySelector('[data-preview-target="bgColor"]');
  const textPick= root.querySelector('input[data-colorpicker="textColor"]');
  const bgPick  = root.querySelector('input[data-colorpicker="bgColor"]');

  const FALLBACK = {
    font: card?.dataset.fallbackFont || "var(--font-serif)",
    text: card?.dataset.fallbackText || "#111827",
    bg:   card?.dataset.fallbackBg   || "#F9FAFB",
  };

  const apply = () => {
    if (card) {
      card.style.fontFamily = (fontSel?.value?.trim() || FALLBACK.font);
    }
    const setColor = (key, input) => {
      const val = (input?.value || "").trim();
      if (!card) return;
      if (key === "text") card.style.color = val || FALLBACK.text;
      if (key === "bg")   card.style.background = val || FALLBACK.bg;
    };
    setColor("text", textInp);
    setColor("bg",   bgInp);

    // バッジの HEX 表示も更新
    root.querySelectorAll('[data-colorpicker]').forEach((picker) => {
      const key = picker.dataset.colorpicker;
      const src = key === "textColor" ? textInp : bgInp;
      const val = (src?.value || "").trim();
      const badge = picker.parentElement?.querySelector(".badge");
      if (badge) badge.textContent = (val || (key === "textColor" ? FALLBACK.text : FALLBACK.bg)).toUpperCase();
    });
  };

  // ピッカー <-> テキスト 双方向
  const bindPair = (text, picker) => {
    if (!text || !picker) return;
    picker.addEventListener("input", e => {
      text.value = e.target.value;
      apply(); saveRecent(text, e.target.value);
    });
    text.addEventListener("input", e => {
      const v = e.target.value;
      if (/^#(?:[0-9a-fA-F]{3}){1,2}$/.test(v)) picker.value = v;
      apply();
    });
  };

  // プリセット
  root.querySelectorAll('[data-color-preset]').forEach(btn => {
    btn.addEventListener("click", (e) => {
      const key = e.currentTarget.dataset.colorPreset;
      const val = e.currentTarget.dataset.value;
      const text   = key === "textColor" ? textInp : bgInp;
      const picker = key === "textColor" ? textPick : bgPick;
      if (text) text.value = val;
      if (picker) picker.value = val;
      apply(); saveRecent(text, val);
    });
  });

  // 未指定
  root.querySelectorAll('[data-clear-color]').forEach(btn => {
    btn.addEventListener("click", (e) => {
      const key = e.currentTarget.dataset.clearColor;
      const text = key === "textColor" ? textInp : bgInp;
      if (text) text.value = "";
      apply();
    });
  });

  // 現在値を拾う
  root.querySelectorAll('[data-pick-current]').forEach(btn => {
    btn.addEventListener("click", (e) => {
      const key = e.currentTarget.dataset.pickCurrent;
      const text = key === "textColor" ? textInp : bgInp;
      const prop = key === "textColor" ? "color" : "backgroundColor";
      const val = card ? rgbToHex(getComputedStyle(card)[prop]) : "";
      if (text && val) text.value = val;
      apply(); saveRecent(text, val);
    });
  });

  // クイックフォント
  root.querySelectorAll('[data-quick-font]').forEach(btn => {
    btn.addEventListener("click", () => {
      if (!fontSel) return;
      fontSel.value = btn.dataset.quickFont;
      fontSel.dispatchEvent(new Event("change"));
    });
  });

  function rgbToHex(rgb) {
    const m = rgb.match(/\d+/g);
    if (!m) return "";
    return "#" + m.slice(0, 3).map(n => ("0" + parseInt(n, 10).toString(16)).slice(-2)).join("");
  }

  // 最近使った色（localStorage）
  function saveRecent(inputEl, hex) {
    if (!hex || !hex.startsWith("#")) return;
    const key = inputEl === textInp ? "recent_text" : "recent_bg";
    const arr = JSON.parse(localStorage.getItem(key) || "[]").filter(v => v !== hex);
    arr.unshift(hex);
    localStorage.setItem(key, JSON.stringify(arr.slice(0, 8)));
    renderRecent();
  }

  function renderRecent() {
    const wrapText = root.querySelector('[data-recent="textColor"]');
    const wrapBg   = root.querySelector('[data-recent="bgColor"]');
    const make = (hex, key) => {
      const b = document.createElement("button");
      b.type = "button";
      b.title = hex;
      b.className = "size-6 rounded-full border";
      b.style.background = hex;
      b.dataset.colorPreset = key;
      b.dataset.value = hex;
      b.addEventListener("click", () => {
        const text = key === "textColor" ? textInp : bgInp;
        const picker = key === "textColor" ? textPick : bgPick;
        if (text) text.value = hex;
        if (picker) picker.value = hex;
        apply(); saveRecent(text, hex);
      });
      return b;
    };
    if (wrapText) {
      wrapText.innerHTML = "";
      (JSON.parse(localStorage.getItem("recent_text") || "[]")).forEach(hex => wrapText.appendChild(make(hex, "textColor")));
    }
    if (wrapBg) {
      wrapBg.innerHTML = "";
      (JSON.parse(localStorage.getItem("recent_bg") || "[]")).forEach(hex => wrapBg.appendChild(make(hex, "bgColor")));
    }
  }

  bindPair(textInp, textPick);
  bindPair(bgInp,   bgPick);
  fontSel?.addEventListener("change", apply);

  renderRecent();
  apply(); // 初期反映
})();
</script>
