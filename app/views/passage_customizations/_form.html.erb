<%# locals: customization:, passage:, url:, submit_label:, fallback: { bg:, text:, font: } %>

<%= form_with model: customization,
              url: url,
              local: true,
              html: { autocomplete: "off" },
              class: "space-y-6" do |f| %>

  <%= f.hidden_field :id if customization.persisted? %>

  <% if customization.errors.any? %>
    <div class="alert alert-error">
      <span>入力にエラーがあるよ（<%= customization.errors.count %>件）</span>
      <ul class="list-disc pl-5">
        <% customization.errors.full_messages.each do |m| %>
          <li><%= m %></li>
        <% end %>
      </ul>
    </div>
  <% end %>

  <div class="grid gap-6 md:grid-cols-2 items-start">
    <!-- ① SPではプレビュー先頭 / md以上は右側に固定 -->
    <div class="order-1 md:order-2 md:sticky md:top-24">
      <div id="preview-card"
           class="relative rounded-2xl p-6 border card-lift"
           style="background:<%= fallback[:bg] %>; color:<%= fallback[:text] %>; font-family:<%= fallback[:font] %>;"
           data-fallback-bg="<%= fallback[:bg] %>"
           data-fallback-text="<%= fallback[:text] %>"
           data-fallback-font="<%= fallback[:font] %>">
        <div class="absolute inset-0 gh-grain pointer-events-none rounded-2xl"></div>

        <% if passage.title.present? || passage.author.present? %>
          <div class="text-[11px] opacity-70 mb-1 font-sans">
            <%= [passage.author, passage.title.presence&.yield_self { |t| "『#{t}』" }].compact.join(" ") %>
          </div>
        <% end %>

        <div class="text-lg md:text-2xl font-semibold leading-relaxed">
          <%= simple_format(h(passage.content)) %>
        </div>
      </div>
    </div>

    <!-- ② 入力（SPでは後ろ / md以上は左） -->
    <div class="order-2 md:order-1 space-y-5">
      <!-- フォント -->
      <div>
        <%= f.label :font, "フォント", class: "block font-semibold mb-1" %>
        <div class="flex gap-2 mb-2">
          <% [["Serif","var(--font-serif)"],["Sans","var(--font-sans)"],["Mono","var(--font-mono)"]].each do |label, val| %>
            <button type="button" class="btn btn-xs" data-quick-font="<%= val %>"><%= label %></button>
          <% end %>
        </div>
        <%= f.select :font,
              options_for_select([
                ["標準（Serif）", "var(--font-serif)"],
                ["標準（Sans）",  "var(--font-sans)"],
                ["等幅（Mono）",  "var(--font-mono)"]
              ], customization.font),
              { include_blank: "（未選択 = 既定）" },
              class: "select select-bordered w-full",
              data: { preview_target: "font" } %>
        <p class="text-xs opacity-70 mt-1">未選択ならカード既定のフォントが使われるよ。</p>
      </div>

      <!-- 文字色 -->
      <%= render "passage_customizations/color_field_with_palette",
            f: f,
            field: :color,
            label: "文字色",
            picker_key: "textColor",
            default_color: customization.color.presence || fallback[:text] %>

      <!-- 背景色 -->
      <%= render "passage_customizations/color_field_with_palette",
            f: f,
            field: :bg_color,
            label: "背景色",
            picker_key: "bgColor",
            default_color: customization.bg_color.presence || fallback[:bg] %>

      <div class="flex gap-2">
        <%= f.submit submit_label, class: "btn btn-primary" %>
        <%= link_to "キャンセル", passage_path(passage), class: "btn btn-ghost" %>
      </div>
    </div>
  </div>
<% end %>

<!-- ③ SP専用：プレビューへジャンプするFAB -->
<button id="jump-preview"
        class="md:hidden fixed bottom-4 right-4 btn btn-primary shadow-lg hidden"
        type="button" aria-label="プレビューへ">
  👁 プレビュー
</button>

<!-- ④ 最小JS：双方向バインド + 初期反映 + FAB表示制御 -->
<script>
(() => {
  const root = document.currentScript.closest(".rounded-3xl") || document;
  const card = root.querySelector("#preview-card");
  const fontSel = root.querySelector('[data-preview-target="font"]');
  const textInp = root.querySelector('[data-preview-target="textColor"]');
  const bgInp   = root.querySelector('[data-preview-target="bgColor"]');
  const textPick= root.querySelector('input[data-colorpicker="textColor"]');
  const bgPick  = root.querySelector('input[data-colorpicker="bgColor"]');
  const fab     = root.querySelector("#jump-preview");

  const FALLBACK = {
    font: card?.dataset.fallbackFont || "var(--font-serif)",
    text: card?.dataset.fallbackText || "#111827",
    bg:   card?.dataset.fallbackBg   || "#F9FAFB",
  };

  const apply = () => {
    if (card) {
      card.style.fontFamily = (fontSel?.value?.trim() || FALLBACK.font);
      card.style.color      = (textInp?.value?.trim() || FALLBACK.text);
      card.style.background = (bgInp  ?.value?.trim() || FALLBACK.bg);
    }
    // バッジ更新（パレット側で .badge を用意している場合）
    root.querySelectorAll('[data-colorpicker]').forEach((picker) => {
      const key = picker.dataset.colorpicker;
      const src = key === "textColor" ? textInp : bgInp;
      const val = (src?.value || "").trim();
      const badge = picker.parentElement?.querySelector(".badge");
      if (badge) badge.textContent = (val || (key === "textColor" ? FALLBACK.text : FALLBACK.bg)).toUpperCase();
    });
  };

  const bindPair = (text, picker) => {
    if (!text || !picker) return;
    picker.addEventListener("input", e => { text.value = e.target.value; apply(); });
    text.addEventListener("input",  e => { if (/^#(?:[0-9a-fA-F]{3}){1,2}$/.test(e.target.value)) picker.value = e.target.value; apply(); });
  };

  // クイックフォント
  root.querySelectorAll('[data-quick-font]').forEach(btn => {
    btn.addEventListener("click", () => {
      if (!fontSel) return;
      fontSel.value = btn.dataset.quickFont;
      fontSel.dispatchEvent(new Event("change"));
    });
  });

  // FAB表示制御（プレビューが画面外に出たら表示）
  if (card && fab && "IntersectionObserver" in window) {
    const io = new IntersectionObserver(([ent]) => {
      fab.classList.toggle("hidden", ent.isIntersecting);
    }, { threshold: 0.1 });
    io.observe(card);

    fab.addEventListener("click", () => {
      card.scrollIntoView({ behavior: "smooth", block: "nearest" });
    });
  }

  fontSel?.addEventListener("change", apply);
  bindPair(textInp, textPick);
  bindPair(bgInp,   bgPick);
  apply(); // 初期反映
})();
</script>